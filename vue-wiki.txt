var MyComponent = Vue.extend({
  // 扩展选项
})
// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建
var myComponentInstance = new MyComponent()
----------------------------------------------------------

循环：
	v-for="name in arr"
		{{$index}}
	
	v-for="name in json"
	{{$index}}	 {{$key}}
----------------------------------------------------------

v-on： 简写为 @

@click=""

----------------------------------------------------------

事件冒泡：

	阻止冒泡：
		a）ev.cancelBubble=true;
		b) @click.stop   =>推荐

----------------------------------------------------------
默认行为：
	组织默认行为：
		a) ev.preventDefault();
		b) #context.prevent =>推荐
		
----------------------------------------------------------
键盘：
	@keydown   $event  ev.keyCode
	@keyup
	
	常用的：
		回车
		原生判定if
		@keyup.13
		@keyup.enter
		
		上、下、 左、右

		@keyup.up/down/left/right

----------------------------------------------------------

属性：
	
	<img v-bind:src="url" alt="" />

	v-bind:src 简写  ：src

	其他的 
		: width   :h eight  :title
	
	class 和 style
	class：
		:class="[n]"   n是数据  对应data：中的n：red  ,red是真的类名。
		:class="[n，m]"  
		:class="{red:true}"    style里的.red 起作用
		:class="{red:a,blue:b}"   对应data：中的 a:true/false, 之后确定style中的red类 是否起作用。
		:class="json"		    对应data：中的data:{
													json:{                   
														red:true,
														blue:false
													}
												}
		
	
	
	style： 
		:style="[c,b]"      
		
				data:{			
					c:{color:'red'},
					b:{backgroundColor:'blue'}
				
				}
		注意:符合样式采用驼峰命名法， backgroundColor
	
	:style="json"

--------------------------------------------------------------------------------------------------------------------
模板：
  
	{{msg}}    双向绑定  数据更新 模板更新
	{{{msg}}}  三括号 HTML转义输出
	
--------------------------------------------------------------------------------------------------------------------
过滤器：-> 过滤器模板数据
	
	系统提供一些过滤器：
		{{msg | filterA |filterB}}
		
--------------------------------------------------------------------------------------------------------------------

交互：
	
	引入：vue-resourse.js
	
	get:
		获取文本数据：
		this.$http.get('a.txt').then(function(res){
			alert(res.data);
		},function(res){
			alert(404);
		});
		给服务器发送数据：  
		
			get.php=>   <?php
							$a=$_Get['a'];
							$b=$_Get['b'];
							echo $a+$b;
						?>
						
		
		this.$http.get('get.php'，{
			a:1，
			b:2
		}).then(function(res){
			alert(res.data);
		},function(res){
			alert(404);
		});
		
		
	post: emulateJSON:true;  模拟JSON数据
	
	
	jsonp:
		this.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',{
							wd:'c'
						},{
							jsonp:'cb' //callback 名字  默认一般为callback
						}).then(function(res){
							alert(res.data.s);
						},function(res){
							alert(res.status);
						});
	
	
	百度jsonp：
	
	搜索接口：
	https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=c&cb=jshow
	确定搜索接口：
	https://www.baidu.com/s?wd=s
	
	
	wd= 搜索内容
	
--------------------------------------------------------------------------------------------------------------------
	
	data 必须是函数

使用组件时，大多数选项可以被传入到 Vue 构造器中，有一个例外： data 必须是函数。 实际上，如果你这么做：

--------------------------------------------------------------------------------------------------------------------
	
 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display 。

注意 v-show 不支持 <template> 语法。
	
	v-if vs. v-show :

v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。

v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。

相比之下， v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。

一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。
	
--------------------------------------------------------------------------------------------------------------------	
	
注意事项

由于 JavaScript 的限制， Vue 不能检测以下变动的数组：

当你直接设置一个项的索引时，例如： vm.items[indexOfItem] = newValue
当你修改数组的长度时，例如： vm.items.length = newLength


为了避免第一种情况，以下两种方式将达到像 vm.items[indexOfItem] = newValue 的效果， 同时也将触发状态更新：	
 

	// Vue.set
Vue.set(example1.items, indexOfItem, newValue)

	// Array.prototype.splice`
example1.items.splice(indexOfItem, 1, newValue)


避免第二种情况，使用 splice：

example1.items.splice(newLength)

--------------------------------------------------------------------------------------------------------------------

在文本区域插值( <textarea></textarea> ) 并不会生效，应用 v-model 来代替
--------------------------------------------------------------------------------------------------------------------


修饰符

.lazy

在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：

<!-- 在 "change" 而不是 "input" 事件中更新 -->
<input v-model.lazy="msg" >
.number

如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：

<input v-model.number="age" type="number">
这通常很有用，因为在 type="number" 时 HTML 中输入的值也总是会返回字符串类型。

.trim

如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：

<input v-model.trim="msg">

--------------------------------------------------------------------------------------------------------------------	

组件在注册之后，便可以在父实例的模块中以自定义元素 <my-component></my-component> 的形式使用。要确保在初始化根实例
--------------------------------------------------------------------------------------------------------------------	



所以要让组件的 v-model 生效，它必须：

接受一个 value 属性
在有新的 value 时触发 input 事件


--------------------------------------------------------------------------------------------------------------------

动态组件

多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is 特性：

var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
<component v-bind:is="currentView">
  <!-- 组件在 vm.currentview 变化时改变！ -->
</component>

也可以直接绑定到组件对象上：

var Home = {
  template: '<p>Welcome home!</p>'
}
var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})

--------------------------------------------------------------------------------------------------------------------
在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。

Vue 组件的 API 来自三部分 - props, events 和 slots ：

Props 允许外部环境传递数据给组件

Events 允许组件触发外部环境的副作用

Slots 允许外部环境将额外的内容组合在组件中。

--------------------------------------------------------------------------------------------------------------------
由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:

var vm = new Vue({
  data: {
    // 声明 message 为一个空值字符串
    message: ''
  },
  template: '<div>{{ message }}</div>'
})
// 之后设置 `message` 
vm.message = 'Hello!'

--------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------